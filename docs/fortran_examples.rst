Fortran v3 example suite status
===============================

This page tracks the vendored upstream SFINCS Fortran v3 example suite
(``examples/sfincs_examples``) from the perspective of **end-to-end output parity**.

For each upstream example input we report:

1. whether ``sfincs_jax`` successfully writes ``sfincsOutput.h5`` for that exact input,
2. whether that exact input has a frozen Fortran output fixture in-repo and matches it,
3. and the reason when parity is not currently verified.

How this table is generated
---------------------------

The table is generated by:

.. code-block:: bash

   python scripts/generate_fortran_example_output_status.py

Generation logic:

- Runs ``sfincs_jax write-output`` semantics for each upstream example input.
- Matches each input against ``tests/ref/*.input.namelist`` by exact file content.
- If a matching frozen ``tests/ref/*.sfincsOutput.h5`` exists, compares datasets with
  ``compare_sfincs_outputs``.
- Otherwise marks the case as ``unverified`` with a concrete reason.

.. note::

   In this repository snapshot, most upstream examples are marked ``unverified`` because
   there is no exact-matching frozen Fortran ``sfincsOutput.h5`` fixture for that specific
   input file. This is different from ``unsupported``: many of those cases do run and write
   output with ``sfincs_jax``.

Output parity table
-------------------

.. include:: _generated/fortran_examples_output_status.rst

Complementary audit
-------------------

A broader capability audit (grid/geometry/write-output support classification) is also
maintained and auto-generated:

.. code-block:: bash

   python scripts/generate_fortran_example_audit.py

.. include:: _generated/fortran_examples_table.rst

Reduced-runtime parity sweep (case-by-case)
-------------------------------------------

For rapid parity iteration, we also keep a reduced-resolution sweep generated with:

.. code-block:: bash

   python scripts/run_reduced_upstream_suite.py --timeout-s 30 --max-attempts 6

This workflow:

1. copies each upstream input into ``tests/reduced_upstream_examples/<case>/input.namelist``,
2. halves resolution axes adaptively until both Fortran and ``sfincs_jax`` runs are under 30s,
3. compares resulting ``sfincsOutput.h5`` files.

The latest generated practical table (with per-case tolerance overrides) is:

.. include:: _generated/reduced_upstream_suite_status.rst

The latest generated strict table (all tolerance overrides ignored) is:

.. include:: _generated/reduced_upstream_suite_status_strict.rst

Recent operator-audit subset (PETSc matrix parity)
--------------------------------------------------

To isolate solver-branch vs operator-assembly differences, we also run
``scripts/compare_petsc_operator.py`` on reduced cases with
``saveMatricesAndVectorsInBinary=.true.`` enabled. This compares Fortran PETSc
matrix action directly against the JAX matrix-free operator action.

Current audited subset:

- ``tests/reduced_inputs/geometryScheme4_2species_noEr.input.namelist``
- ``tests/reduced_inputs/HSX_FPCollisions_DKESTrajectories.input.namelist``
- ``tests/reduced_inputs/transportMatrix_geometryScheme11.input.namelist``
- ``tests/reduced_inputs/filteredW7XNetCDF_2species_magneticDrifts_noEr.input.namelist``
- ``tests/reduced_inputs/filteredW7XNetCDF_2species_magneticDrifts_withEr.input.namelist``

For these cases, PETSc-vs-JAX operator deltas are already near roundoff
(``~1e-10`` to ``~1e-14`` in matrix-action checks), so remaining output mismatches
are tracked as diagnostics/solver-branch effects rather than missing operator terms.

Field-wise reduced-suite tolerances are stored in
``tests/reduced_inputs/*.compare_tolerances.json`` and applied automatically in
the practical report. The strict report ignores all of these overrides.

Promoted reduced-input fixtures
-------------------------------

Whenever a case reaches ``parity_ok`` in the reduced runner, its adapted input is promoted to:

``tests/reduced_inputs/<case>.input.namelist``

Current promoted fixtures:

- ``tests/reduced_inputs/HSX_FPCollisions_DKESTrajectories.input.namelist``
- ``tests/reduced_inputs/filteredW7XNetCDF_2species_magneticDrifts_noEr.input.namelist``
- ``tests/reduced_inputs/filteredW7XNetCDF_2species_magneticDrifts_withEr.input.namelist``
- ``tests/reduced_inputs/geometryScheme4_2species_noEr.input.namelist``
- ``tests/reduced_inputs/inductiveE_noEr.input.namelist``
- ``tests/reduced_inputs/monoenergetic_geometryScheme11.input.namelist``
- ``tests/reduced_inputs/monoenergetic_geometryScheme5_ASCII.input.namelist``
- ``tests/reduced_inputs/monoenergetic_geometryScheme5_netCDF.input.namelist``
- ``tests/reduced_inputs/transportMatrix_geometryScheme11.input.namelist``

These are intended as fast, reusable parity gates for CI and local development.

Blocker typing used for failing reduced cases
---------------------------------------------

The reduced runner classifies non-parity cases into:

- ``unsupported physics/path``
- ``geometry parsing mismatch``
- ``solver branch mismatch``
- ``output field mismatch``

and also records a compact print-parity score (shared runtime-log signals between
Fortran and ``sfincs_jax``) to track progress toward terminal-output parity.
