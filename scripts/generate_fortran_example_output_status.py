#!/usr/bin/env python
from __future__ import annotations

import argparse
from dataclasses import dataclass
import hashlib
import shutil
import sys
import tempfile
from pathlib import Path

_REPO_ROOT = Path(__file__).resolve().parents[1]
if str(_REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(_REPO_ROOT))

from sfincs_jax.compare import compare_sfincs_outputs
from sfincs_jax.io import localize_equilibrium_file_in_place, write_sfincs_jax_output_h5
from sfincs_jax.namelist import read_sfincs_input


@dataclass(frozen=True)
class CaseRow:
    case: str
    geometry_scheme: int | None
    rhs_mode: int
    write_output: str
    output_parity: str
    reason: str


def _file_hash(path: Path) -> str:
    return hashlib.sha256(path.read_bytes()).hexdigest()


def _fixture_index(ref_dir: Path) -> dict[str, tuple[Path, Path]]:
    index: dict[str, tuple[Path, Path]] = {}
    for input_path in sorted(ref_dir.glob("*.input.namelist")):
        base = input_path.name.replace(".input.namelist", "")
        output_path = ref_dir / f"{base}.sfincsOutput.h5"
        if output_path.exists():
            index[_file_hash(input_path)] = (input_path, output_path)
    return index


def _as_short_error(exc: Exception) -> str:
    msg = f"{type(exc).__name__}: {exc}"
    msg = msg.replace("\n", " ")
    return msg if len(msg) <= 160 else (msg[:157] + "...")


def _rst_escape(s: str) -> str:
    return s.replace("`", "``")


def _parity_status_for_case(
    *,
    case_dir: Path,
    fixture_index: dict[str, tuple[Path, Path]],
    compute_transport_matrix: bool,
    rtol: float,
    atol: float,
) -> CaseRow:
    case = case_dir.name
    source_input_hash = _file_hash(case_dir / "input.namelist")
    with tempfile.TemporaryDirectory(prefix=f"sfincs_jax_case_{case}_") as tmp:
        run_dir = Path(tmp) / case
        shutil.copytree(case_dir, run_dir)

        input_path = run_dir / "input.namelist"
        localize_equilibrium_file_in_place(input_namelist=input_path, overwrite=False)
        nml = read_sfincs_input(input_path)
        general = nml.group("general")
        geometry = nml.group("geometryParameters")
        rhs_mode = int(general.get("RHSMODE", 1))
        geometry_scheme = int(geometry.get("GEOMETRYSCHEME")) if "GEOMETRYSCHEME" in geometry else None
        run_transport_matrix = bool(compute_transport_matrix and rhs_mode in {2, 3})

        out_path = run_dir / "sfincsOutput_jax.h5"
        try:
            write_sfincs_jax_output_h5(
                input_namelist=input_path,
                output_path=out_path,
                compute_transport_matrix=run_transport_matrix,
            )
        except Exception as exc:  # noqa: BLE001
            return CaseRow(
                case=case,
                geometry_scheme=geometry_scheme,
                rhs_mode=rhs_mode,
                write_output="no",
                output_parity="no",
                reason=_as_short_error(exc),
            )

        fixture = fixture_index.get(source_input_hash)
        if fixture is None:
            return CaseRow(
                case=case,
                geometry_scheme=geometry_scheme,
                rhs_mode=rhs_mode,
                write_output="yes",
                output_parity="unverified",
                reason=(
                    "No exact-matching frozen Fortran fixture input in tests/ref; "
                    "parity for this exact case not established in-repo."
                ),
            )

        fixture_input, fixture_h5 = fixture
        results = compare_sfincs_outputs(a_path=out_path, b_path=fixture_h5, rtol=rtol, atol=atol)
        bad = [r for r in results if not r.ok]
        if not bad:
            return CaseRow(
                case=case,
                geometry_scheme=geometry_scheme,
                rhs_mode=rhs_mode,
                write_output="yes",
                output_parity="yes",
                reason=f"Matches frozen Fortran fixture `{fixture_input.name}`.",
            )

        return CaseRow(
            case=case,
            geometry_scheme=geometry_scheme,
            rhs_mode=rhs_mode,
            write_output="yes",
            output_parity="no",
            reason=f"{len(bad)} common datasets outside tolerance vs `{fixture_input.name}`.",
        )


def _write_table(rows: list[CaseRow], out_path: Path) -> None:
    out_path.parent.mkdir(parents=True, exist_ok=True)
    counts: dict[str, int] = {}
    for row in rows:
        counts[row.output_parity] = counts.get(row.output_parity, 0) + 1

    lines: list[str] = []
    lines.append(".. NOTE: Auto-generated by `scripts/generate_fortran_example_output_status.py`.\n\n")
    lines.append(f"- Total examples scanned: **{len(rows)}**\n")
    lines.append("- Output parity status counts: " + ", ".join(f"{k}={v}" for k, v in sorted(counts.items())) + "\n\n")
    lines.append(".. list-table:: Upstream Fortran v3 examples: output parity status\n")
    lines.append("   :header-rows: 1\n")
    lines.append("   :widths: 28 10 8 8 10 36\n\n")
    lines.append("   * - Example\n")
    lines.append("     - geometryScheme\n")
    lines.append("     - RHSMode\n")
    lines.append("     - write-output\n")
    lines.append("     - output parity\n")
    lines.append("     - Reason\n")

    for row in sorted(rows, key=lambda r: r.case.lower()):
        lines.append(f"   * - {_rst_escape(row.case)}\n")
        lines.append(f"     - {'' if row.geometry_scheme is None else row.geometry_scheme}\n")
        lines.append(f"     - {row.rhs_mode}\n")
        lines.append(f"     - {row.write_output}\n")
        lines.append(f"     - {_rst_escape(row.output_parity)}\n")
        lines.append(f"     - {_rst_escape(row.reason)}\n")

    out_path.write_text("".join(lines), encoding="utf-8")


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate per-example output parity status for vendored Fortran v3 cases.")
    parser.add_argument(
        "--examples-root",
        type=Path,
        default=Path(__file__).resolve().parents[1] / "examples" / "sfincs_examples",
    )
    parser.add_argument(
        "--ref-dir",
        type=Path,
        default=Path(__file__).resolve().parents[1] / "tests" / "ref",
    )
    parser.add_argument(
        "--out",
        type=Path,
        default=Path(__file__).resolve().parents[1] / "docs" / "_generated" / "fortran_examples_output_status.rst",
    )
    parser.add_argument("--rtol", type=float, default=1e-8)
    parser.add_argument("--atol", type=float, default=1e-8)
    parser.add_argument(
        "--compute-transport-matrix",
        action="store_true",
        help="Also run RHSMode=2/3 transport-matrix solve loops for those cases (slower).",
    )
    args = parser.parse_args()

    examples_root = Path(args.examples_root)
    if not examples_root.exists():
        raise SystemExit(f"examples root does not exist: {examples_root}")
    ref_dir = Path(args.ref_dir)
    if not ref_dir.exists():
        raise SystemExit(f"ref dir does not exist: {ref_dir}")

    fixture_index = _fixture_index(ref_dir)
    rows: list[CaseRow] = []
    for input_path in sorted(examples_root.rglob("input.namelist")):
        rows.append(
            _parity_status_for_case(
                case_dir=input_path.parent,
                fixture_index=fixture_index,
                compute_transport_matrix=bool(args.compute_transport_matrix),
                rtol=float(args.rtol),
                atol=float(args.atol),
            )
        )
    _write_table(rows, Path(args.out))
    print(f"Wrote {args.out} ({len(rows)} cases).")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
